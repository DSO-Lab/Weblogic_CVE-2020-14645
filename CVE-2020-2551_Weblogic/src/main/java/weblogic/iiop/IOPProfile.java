package weblogic.iiop;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.Collection;
import weblogic.corba.cos.transactions.TransactionPolicyComponent;
import weblogic.corba.idl.poa.PolicyImpl;
import weblogic.diagnostics.debug.DebugLogger;
import weblogic.iiop.csi.CompoundSecMechList;
import weblogic.kernel.Kernel;
import weblogic.kernel.KernelStatus;
import weblogic.rmi.internal.RuntimeDescriptor;
import weblogic.security.service.SecurityServiceManager;
import weblogic.utils.collections.NumericKeyHashMap;

public final class IOPProfile extends Profile {
  private static final DebugLogger debugIIOPDetail = DebugLogger.getDebugLogger("DebugIIOPDetail");
  
  public static final int PORT_DISABLED = 0;
  
  private byte major;
  
  private byte minor;
  
  private String host;
  
  private InetAddress canonicalHost;
  
  private transient ConnectionKey address = null;
  
  private int port;
  
  private boolean readSecurely = false;
  
  private boolean clusterable = false;
  
  int securePort = -1;
  
  private ObjectKey key;
  
  private TargetAddress targetAddress;
  
  private TaggedComponent[] taggedComponents;
  
  private int ncomps;
  
  private static final int MAX_COMPONENTS = 16;
  
  public IOPProfile(String host, int port, ObjectKey key) {
    this(host, port, key, null);
  }
  
  public IOPProfile(String host, int port, ObjectKey key, String applicationName) {
    this(host, port, key, applicationName, (byte)1, IIOPClientService.defaultGIOPMinorVersion, null, null);
  }
  
  IOPProfile(String host, int port, ObjectKey key, String applicationName, byte major, byte minor, ClusterComponent crefs, RuntimeDescriptor runtimeDescriptor) {
    this(host, port, key, applicationName, major, minor, crefs, runtimeDescriptor, null);
  }
  
  IOPProfile(String host, int port, ObjectKey key, String applicationName, byte major, byte minor, ClusterComponent crefs, RuntimeDescriptor runtimeDescriptor, NumericKeyHashMap policies) {
    super(0);
    this.host = host;
    this.port = port;
    this.key = key;
    this.targetAddress = new TargetAddress(key);
    this.major = major;
    this.minor = minor;
    this.ncomps = 0;
    if (major >= 1 && minor >= 1) {
      this.taggedComponents = new TaggedComponent[16];
      this.taggedComponents[this.ncomps++] = CodeSetsComponent.getDefault();
      if (IIOPClientService.useSerialFormatVersion2)
        this.taggedComponents[this.ncomps++] = SFVComponent.VERSION_2; 
      if (Kernel.isServer())
        if (key.isWLSKey()) {
          this.taggedComponents[this.ncomps++] = new CodebaseComponent(key.getTarget(), applicationName);
          if (runtimeDescriptor != null && runtimeDescriptor.getMethodsAreTransactional()) {
            this.taggedComponents[this.ncomps++] = (TaggedComponent)TransactionPolicyComponent.EJB_OTS_POLICY;
          } else if (policies != null && policies.get(55L) != null) {
            this.taggedComponents[this.ncomps++] = TransactionPolicyComponent.getInvocationPolicy(((PolicyImpl)policies.get(55L)).policy_value());
          } 
          if (policies == null) {
            this.taggedComponents[this.ncomps++] = (TaggedComponent)TransactionPolicyComponent.EJB_INV_POLICY;
          } else if (policies.get(56L) != null) {
            this.taggedComponents[this.ncomps++] = TransactionPolicyComponent.getOTSPolicy(((PolicyImpl)policies.get(56L)).policy_value());
          } 
          if (!KernelStatus.isServer() || SecurityServiceManager.isSecurityServiceInitialized()) {
            if (Kernel.DEBUG && debugIIOPDetail.isDebugEnabled())
              p("create compound secmechlist for IOR: " + applicationName); 
            this.taggedComponents[this.ncomps++] = (TaggedComponent)new CompoundSecMechList(host, key.getTarget(), runtimeDescriptor);
          } 
          if (runtimeDescriptor != null && runtimeDescriptor.getIntegrity() != null && "required".equals(runtimeDescriptor.getIntegrity()))
            this.port = 0; 
          if (key.isLocalKey())
            this.securePort = SSLSecTransComponent.getSingleton().getPort(); 
        }  
      if (crefs != null)
        this.taggedComponents[this.ncomps++] = crefs; 
    } 
  }
  
  IOPProfile() {
    super(0);
  }
  
  IOPProfile(IOPProfile other) {
    super(0);
    this.major = other.major;
    this.minor = other.minor;
    this.host = other.host;
    this.port = other.port;
    this.readSecurely = other.readSecurely;
    this.securePort = other.securePort;
    this.key = other.key;
    this.targetAddress = other.targetAddress;
    this.ncomps = other.ncomps;
    this.taggedComponents = new TaggedComponent[other.taggedComponents.length];
    for (int i = 0; i < this.taggedComponents.length; i++)
      this.taggedComponents[i] = other.taggedComponents[i]; 
  }
  
  void setClusterComponent(ClusterComponent cc) {
    int newncomps = 0;
    for (int i = 0; i < this.ncomps; i++) {
      if (!(this.taggedComponents[i] instanceof ClusterComponent))
        this.taggedComponents[newncomps++] = this.taggedComponents[i]; 
    } 
    if (cc != null) {
      if (newncomps + 1 >= this.taggedComponents.length) {
        TaggedComponent[] tmp = new TaggedComponent[newncomps + 1];
        System.arraycopy(this.taggedComponents, 0, tmp, 0, newncomps);
        this.taggedComponents = tmp;
      } 
      this.taggedComponents[newncomps++] = cc;
    } 
  }
  
  public final String getHost() {
    return this.host;
  }
  
  public final InetAddress getHostAddress() throws UnknownHostException {
    if (this.canonicalHost == null)
      this.canonicalHost = InetAddress.getByName(this.host); 
    return this.canonicalHost;
  }
  
  final boolean isSecure() {
    return ((readSecurely() || getPort() <= 0) && getSecurePort() > 0);
  }
  
  public final void makeSecure() {
    if (getSecurePort() > 0 && getPort() > 0)
      this.port = 0; 
  }
  
  public final ConnectionKey getConnectionKey() {
    if (this.address == null)
      try {
        if (isSecure()) {
          String host = (getSecureHost() == null) ? getHost() : getSecureHost();
          this.address = new ConnectionKey(InetAddress.getByName(host).getHostAddress(), getSecurePort());
        } else {
          this.address = new ConnectionKey(getHostAddress().getHostAddress(), getPort());
        } 
      } catch (UnknownHostException uhe) {
        if (isSecure()) {
          String host = (getSecureHost() == null) ? getHost() : getSecureHost();
          this.address = new ConnectionKey(host, getSecurePort());
        } else {
          this.address = new ConnectionKey(getHost(), getPort());
        } 
      }  
    return this.address;
  }
  
  public final int getPort() {
    return this.port;
  }
  
  public final int getSecurePort() {
    if (this.securePort < 0) {
      TaggedComponent tc = getComponent(33);
      if (tc != null)
        this.securePort = ((CompoundSecMechList)tc).getSecurePort(); 
      if (this.securePort < 0) {
        SSLSecTransComponent ssl = (SSLSecTransComponent)getComponent(20);
        if (ssl != null)
          this.securePort = ssl.getPort(); 
      } 
    } 
    return this.securePort;
  }
  
  public final String getSecureHost() {
    TaggedComponent tc = getComponent(33);
    if (tc != null)
      return ((CompoundSecMechList)tc).getSecureHost(); 
    return null;
  }
  
  public final boolean readSecurely() {
    return this.readSecurely;
  }
  
  public final byte getMinorVersion() {
    return this.minor;
  }
  
  public final byte getMajorVersion() {
    return this.major;
  }
  
  public final ObjectKey getObjectKey() {
    return this.key;
  }
  
  public final boolean isTransactional() {
    TransactionPolicyComponent tx = (TransactionPolicyComponent)getComponent(31);
    if (tx != null && tx.getPolicy() != 2)
      return true; 
    return false;
  }
  
  public final boolean isClusterable() {
    if (!this.clusterable && 
      getComponent(1111834883) != null)
      this.clusterable = true; 
    return this.clusterable;
  }
  
  public final TaggedComponent getComponent(int tag) {
    if (this.taggedComponents == null)
      return null; 
    for (int i = 0; i < this.ncomps; i++) {
      if ((this.taggedComponents[i]).tag == tag)
        return this.taggedComponents[i]; 
    } 
    return null;
  }
  
  public final void removeComponent(int tag) {
    TaggedComponent tc = getComponent(tag);
    if (tc != null) {
      Collection c = Arrays.asList((Object[])this.taggedComponents);
      c.remove(tc);
      this.taggedComponents = (TaggedComponent[])c.toArray((Object[])this.taggedComponents);
      this.ncomps--;
    } 
  }
  
  final TargetAddress getTargetAddress() {
    return this.targetAddress;
  }
  
  public final boolean useSAS() {
    TaggedComponent tc = getComponent(33);
    if (tc != null)
      return ((CompoundSecMechList)tc).useSAS(); 
    return false;
  }
  
  public final byte[] getGSSUPTarget() {
    TaggedComponent tc = getComponent(33);
    if (tc != null)
      return ((CompoundSecMechList)tc).getGSSUPTarget(); 
    return null;
  }
  
  public final boolean isGSSUPTargetStateful() {
    TaggedComponent tc = getComponent(33);
    if (tc != null)
      return ((CompoundSecMechList)tc).isGSSUPTargetStateful(); 
    return false;
  }
  
  public byte getMaxStreamFormatVersion() {
    SFVComponent sfv = (SFVComponent)getComponent(38);
    if (sfv != null)
      return sfv.getMaxFormatVersion(); 
    return 1;
  }
  
  public void read(IIOPInputStream in) {
    long handle = in.startEncapsulation();
    if (in.isSecure())
      this.readSecurely = true; 
    this.major = in.read_octet();
    this.minor = in.read_octet();
    ConnectionKey addr = new ConnectionKey(in);
    this.key = new ObjectKey(in);
    this.targetAddress = new TargetAddress(this.key);
    if (this.key.isLocalKey())
      addr = addr.readResolve(in); 
    this.host = IOPTarget.host;
    this.port = IOPTarget.port;
    if (Kernel.DEBUG && debugIIOPDetail.isDebugEnabled())
      p("read() preamble: " + this.major + "." + this.minor + " profile to " + this.host + ":" + this.port + " @" + in.pos()); 
    if (this.major >= 1 && this.minor >= 1) {
      this.ncomps = in.read_long();
      if (Kernel.DEBUG && debugIIOPDetail.isDebugEnabled())
        p("read() " + this.ncomps + " components @" + in.pos()); 
      this.taggedComponents = new TaggedComponent[this.ncomps];
      for (int i = 0; i < this.ncomps; i++) {
        this.taggedComponents[i] = TaggedComponent.readComponent(in, this.key.getTarget());
        switch (this.taggedComponents[i].getTag()) {
          case 1111834883:
            this.clusterable = true;
            break;
        } 
      } 
    } 
    in.endEncapsulation(handle);
    if (Kernel.DEBUG && debugIIOPDetail.isDebugEnabled())
      p("read " + this); 
  }
  
  public void write(IIOPOutputStream out) {
    out.write_long(0);
    long handle = out.startEncapsulation();
    out.write_octet(this.major);
    out.write_octet(this.minor);
    ConnectionKey addr = new ConnectionKey(this.host, this.port);
    if (this.key.getTarget() != null) {
      addr.writeForChannel(out, this.key.getTarget());
    } else {
      addr.write(out);
    } 
    this.key.write(out);
    if (this.major >= 1 && this.minor >= 1) {
      if (out.isSecure() && this.key.isLocalKey() && Kernel.isServer()) {
        out.write_long(this.ncomps + 1);
      } else {
        out.write_long(this.ncomps);
      } 
      for (int i = 0; i < this.ncomps; i++)
        this.taggedComponents[i].write(out); 
      if (out.isSecure() && this.key.isLocalKey() && Kernel.isServer())
        SSLSecTransComponent.getSingleton().write(out); 
    } 
    out.endEncapsulation(handle);
    if (Kernel.DEBUG && debugIIOPDetail.isDebugEnabled())
      p("wrote " + this); 
  }
  
  public final int hashCode() {
    return this.port ^ this.host.hashCode() ^ this.key.hashCode();
  }
  
  public final boolean equals(Object o) {
    try {
      IOPProfile other = (IOPProfile)o;
      if (this.key.isLocalKey() && !Kernel.isServer() && this.key.equals(other.key))
        return true; 
      if (this.port != other.port || (this.host != other.host && this.host.hashCode() != other.host.hashCode() && !this.host.equals(other.host)) || (this.key != other.key && !this.key.equals(other.key)))
        return false; 
      return true;
    } catch (ClassCastException cce) {
      return false;
    } 
  }
  
  public String toString() {
    String str = "IOP Profile (ver = " + this.major + "." + this.minor + ", host = " + this.host + ",port = " + this.port + ",key = " + this.key + ", taggedComponents = ";
    if (this.taggedComponents != null)
      for (int i = 0; i < this.taggedComponents.length; i++)
        str = str + this.taggedComponents[i];  
    return str + ")";
  }
  
  private static void p(String s) {
    System.err.println("<IOPProfile> " + s);
  }
}
