package weblogic.iiop.ior;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import org.omg.CORBA_2_3.portable.InputStream;
import weblogic.iiop.IOPTarget;
import weblogic.iiop.protocol.CorbaInputStream;
import weblogic.iiop.protocol.CorbaOutputStream;
import weblogic.iiop.protocol.IiopProtocolFacade;
import weblogic.iiop.protocol.ListenPoint;
import weblogic.protocol.ServerIdentity;
import weblogic.utils.Hex;

public final class IOPProfile extends Profile {
    public static final int PORT_DISABLED = 0;

    private byte major;

    private byte minor;

    private String host;

    private InetAddress canonicalHost;

    private transient ListenPoint address = null;

    private int port;

    private boolean readSecurely = false;

    private boolean clusterable = false;

    private int securePort = -1;

    private byte[] key;

    private transient Object objectKey;

    private List<TaggedComponent> taggedComponents;

    public void disablePlainPort() {
        this.port = 0;
    }

    private boolean taggedComponentsSupported() {
        return (this.major > 1 || (this.major == 1 && this.minor > 0));
    }

    public void addComponent(TaggedComponent component) {
        if (this.taggedComponents == null)
            this.taggedComponents = new ArrayList<TaggedComponent>();
        this.taggedComponents.add(component);
    }

    public IOPProfile(String host, int port, byte[] key, byte major, byte minor) {
        super(0);
        this.host = host;
        this.port = port;
        this.key = key;
        this.major = major;
        this.minor = minor;
    }

    IOPProfile() {
        super(0);
    }

    public IOPProfile(IOPProfile other) {
        super(0);
        this.major = other.major;
        this.minor = other.minor;
        this.host = other.host;
        this.port = other.port;
        this.readSecurely = other.readSecurely;
        this.securePort = other.securePort;
        this.key = other.key;
        this.taggedComponents = (other.taggedComponents == null) ? null : new ArrayList<TaggedComponent>(other.taggedComponents);
    }

    public void setClusterComponent(ClusterComponent clusterComponent) {
        removeExistingClusterComponents();
        if (clusterComponent != null)
            addComponent(clusterComponent);
    }

    private void removeExistingClusterComponents() {
        for (Iterator<TaggedComponent> each = this.taggedComponents.iterator(); each.hasNext();) {
            if (each.next() instanceof ClusterComponent)
                each.remove();
        }
    }

    public final String getHost() {
        return this.host;
    }

    public final InetAddress getHostAddress() throws UnknownHostException {
        if (this.canonicalHost == null)
            this.canonicalHost = InetAddressHelper.getByName(this.host);
        return this.canonicalHost;
    }

    final boolean isSecure() {
        return ((readSecurely() || getPort() <= 0) && getSecurePort() > 0);
    }

    public final void makeSecure() {
        if (getSecurePort() > 0 && getPort() > 0)
            this.port = 0;
    }

    final ListenPoint getListenPoint() {
        if (this.address == null)
            try {
                if (isSecure()) {
                    String host = (getSecureHost() == null) ? getHost() : getSecureHost();
                    this.address = new ListenPoint(InetAddressHelper.getByName(host).getHostAddress(), getSecurePort());
                } else {
                    this.address = new ListenPoint(getHostAddress().getHostAddress(), getPort());
                }
            } catch (UnknownHostException uhe) {
                if (isSecure()) {
                    String host = (getSecureHost() == null) ? getHost() : getSecureHost();
                    this.address = new ListenPoint(host, getSecurePort());
                } else {
                    this.address = new ListenPoint(getHost(), getPort());
                }
            }
        return this.address;
    }

    public final int getPort() {
        return this.port;
    }

    public final int getSecurePort() {
        if (this.securePort < 0) {
            TaggedComponent tc = getComponent(33);
            if (tc != null)
                this.securePort = ((CompoundSecMechList)tc).getSecurePort();
            if (this.securePort < 0) {
                SSLSecTransComponent ssl = getComponent(20);
                if (ssl != null)
                    this.securePort = ssl.getPort();
            }
        }
        return this.securePort;
    }

    public void setSecurePort(int securePort) {
        this.securePort = securePort;
    }

    public final String getSecureHost() {
        TaggedComponent tc = getComponent(33);
        if (tc != null)
            return ((CompoundSecMechList)tc).getSecureHost();
        return null;
    }

    private boolean readSecurely() {
        return this.readSecurely;
    }

    public final byte getMinorVersion() {
        return this.minor;
    }

    public byte[] getKey() {
        return this.key;
    }

    public void setObjectKey(Object objectKey) {
        this.objectKey = objectKey;
    }

    public final Object getObjectKey() {
        if (this.objectKey == null)
            synchronized (this) {
                if (this.objectKey == null)
                    this.objectKey = IiopProtocolFacade.toObjectKey(this.key);
            }
        return this.objectKey;
    }

    public final boolean isTransactional() {
        TransactionPolicyComponent tx = getComponent(31);
        return (tx != null && tx.getPolicy() != 2);
    }

    public final boolean isClusterable() {
        if (!this.clusterable &&
                getComponent(1111834883) != null)
            this.clusterable = true;
        return this.clusterable;
    }

    public final <T extends TaggedComponent> T getComponent(int tag) {
        if (this.taggedComponents != null)
            for (TaggedComponent component : this.taggedComponents) {
                if (component.tag == tag)
                    return (T)component;
            }
        return null;
    }

    public final boolean useSAS() {
        TaggedComponent tc = getComponent(33);
        return (tc != null && ((CompoundSecMechList)tc).useSAS());
    }

    public byte getMaxStreamFormatVersion() {
        SFVComponent sfv = getComponent(38);
        return (sfv == null) ? 1 : sfv.getMaxFormatVersion();
    }

    public void read(CorbaInputStream in) {
        long handle = in.startEncapsulation();
        if (in.isSecure())
            this.readSecurely = true;
        this.major = in.read_octet();
        this.minor = in.read_octet();
        ListenPoint addr = new ListenPoint((InputStream)in);
        this.key = in.read_octet_sequence(1048576);
        this.objectKey = IiopProtocolFacade.toObjectKey(this.key);
        if (IiopProtocolFacade.mustReplaceAddress(this.objectKey))
            addr = addr.replaceFromChannel((InputStream)in);
        this.host = IOPTarget.host;
        this.port = IOPTarget.port;
        if (taggedComponentsSupported()) {
            ServerIdentity target = IiopProtocolFacade.getTargetForRead(this.objectKey);
            long size = in.read_long();
            this.taggedComponents = new ArrayList<TaggedComponent>();
            for (int i = 0; i < size; i++) {
                TaggedComponent taggedComponent = TaggedComponent.readComponent(in, target);
                this.taggedComponents.add(taggedComponent);
                if (taggedComponent.getTag() == 1111834883)
                    this.clusterable = true;
            }
        }
        in.endEncapsulation(handle);
    }

    public void write(CorbaOutputStream out) {
        out.write_long(0);
        long handle = out.startEncapsulation();
        out.write_octet(this.major);
        out.write_octet(this.minor);
        IiopProtocolFacade.writeListenPoint(out, getObjectKey(), new ListenPoint(this.host, this.port));
        out.write_octet_sequence(this.key);
        if (taggedComponentsSupported()) {
            if (needToAddSSLSecTransComponent(out)) {
                out.write_long(this.taggedComponents.size() + 1);
            } else {
                out.write_long(this.taggedComponents.size());
            }
            for (TaggedComponent taggedComponent : this.taggedComponents)
                taggedComponent.write(out);
            if (needToAddSSLSecTransComponent(out))
                SSLSecTransComponent.getSingleton().write(out);
        }
        out.endEncapsulation(handle);
    }

    private boolean needToAddSSLSecTransComponent(CorbaOutputStream out) {
        return (out.isSecure() && IiopProtocolFacade.isServerLocalObject(getObjectKey()));
    }

    public final int hashCode() {
        return this.port ^ this.host.hashCode() ^ Arrays.hashCode(this.key);
    }

    public final boolean equals(Object o) {
        return (this == o || (o instanceof IOPProfile && equals((IOPProfile)o)));
    }

    private boolean equals(IOPProfile other) {
        return (IiopProtocolFacade.fastEquals(getObjectKey(), other.getObjectKey()) || standardEquals(other));
    }

    private boolean standardEquals(IOPProfile other) {
        return (this.port == other.port && this.host.equals(other.host) && this.key == other.key);
    }

    public String toString() {
        String str = "IOP Profile (ver = " + this.major + "." + this.minor + ", host = " + this.host + ",port = " + this.port + ",key = " + Hex.asHex(this.key) + ", \ntaggedComponents = ";
        if (this.taggedComponents != null)
            for (TaggedComponent taggedComponent : this.taggedComponents)
                str = str + '\n' + taggedComponent;
        return str + ")";
    }
}
